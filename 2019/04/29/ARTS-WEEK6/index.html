<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>

    <!--Description-->

    

    
        <meta name="description" content="本周ARTS上周身体不适，休息了一周，下周补上
本周ARTS打卡内容：

Algorithm 来源 LeetCode22
Review 分享 用Go kit写微服务
Tip 分享 cookie、 sessionStorage 、localStorage之间的区别和使用
Share 分享 golang"/>
    

    <!--Author-->
    
        <meta name="author" content="Leitty"/>
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="ARTS-WEEK6"/>
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="本周ARTS上周身体不适，休息了一周，下周补上
本周ARTS打卡内容：

Algorithm 来源 LeetCode22
Review 分享 用Go kit写微服务
Tip 分享 cookie、 sessionStorage 、localStorage之间的区别和使用
Share 分享 golang"/>
    

    <!--Open Graph Site Name-->
        <meta property="og:site_name" content="Leitty Blog"/>

    <!--Type page-->
    
        <meta property="og:type" content="article"/>
    

    <!--Page Cover-->
    
    
        <meta property="og:image" content="https://leitty.github.io/img/home-bg.jpg"/>
    

        <meta name="twitter:card" content="summary_large_image"/>

    

    
        <meta name="twitter:image" content="https://leitty.github.io/img/home-bg.jpg"/>
    

    <!-- Title -->
    
    <title>ARTS-WEEK6 - Leitty Blog</title>

    <!-- Bootstrap Core CSS -->
    <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet"/>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/>
    <link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css"/>
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css"/>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet"/>

    <!-- Google Analytics -->
    


    <!-- favicon -->
    

</head>


<body>

    <!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Configurable Title</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <a href="/">
                            
                                Home
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives">
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/tags">
                            
                                Tags
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/categories">
                            
                                Categories
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="https://github.com/Leitty">
                            
                                <i class="fa fa-github fa-stack-2x"></i>
                            
                        </a>
                    </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header" style="background-image: url('/img/home-bg.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>ARTS-WEEK6</h1>
                    
                    <span class="meta">
                        <!-- Date and Author -->
                        
                        
                            2019-04-29
                        
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Tags and categories -->
           
                <div class="col-lg-4 col-lg-offset-2 col-md-5 col-md-offset-1 post-tags">
                    
                        


<a href="/tags/ARTS/">#ARTS</a> <a href="/tags/Leetcode/">#Leetcode</a>


                    
                </div>
                <div class="col-lg-4 col-md-5 post-categories">
                    
                </div>
            

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <h2 id="本周ARTS"><a href="#本周ARTS" class="headerlink" title="本周ARTS"></a>本周ARTS</h2><p>上周身体不适，休息了一周，下周补上</p>
<p>本周ARTS打卡内容：</p>
<ol>
<li>Algorithm 来源 LeetCode22</li>
<li>Review 分享 用Go kit写微服务</li>
<li>Tip 分享 cookie、 sessionStorage 、localStorage之间的区别和使用</li>
<li>Share 分享 golang的container/heap包详解</li>
</ol>
<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>LeetCode的22题，产生合法的括号字符串：</p>
<p><a href="https://leetcode.com/problems/generate-parentheses/" target="_blank" rel="noopener">https://leetcode.com/problems/generate-parentheses/</a></p>
<p>比如给定 n=3 ，产生：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &quot;((()))&quot;,</span><br><span class="line">  &quot;(()())&quot;,</span><br><span class="line">  &quot;(())()&quot;,</span><br><span class="line">  &quot;()(())&quot;,</span><br><span class="line">  &quot;()()()&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>可以用递归的方法考虑：<code>G(n)</code>表示长度为n产生的字符串组，所以:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">G(n) = “(”+G(0)+&quot;)&quot;×G(n-1-0) +</span><br><span class="line">       “(”+G(1)+&quot;)&quot;×G(n-1-1) +</span><br><span class="line">       “(”+G(2)+&quot;)&quot;×G(n-1-3) +</span><br><span class="line">       ...</span><br><span class="line">       “(”+G(i)+&quot;)&quot;×G(n-1-i) +</span><br><span class="line">       ...</span><br><span class="line">       “(”+G(n-1)+&quot;)&quot;×G(0)</span><br></pre></td></tr></table></figure></p>
<p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">func generateParenthesis(n int) []string &#123;</span><br><span class="line">	if n == 0 &#123;</span><br><span class="line">		return []string&#123;&quot;&quot;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	var results = []string&#123;&#125;</span><br><span class="line">	for i := 0 ; i &lt; n ; i++ &#123;</span><br><span class="line">		substr1 := generateParenthesis(i)</span><br><span class="line">		substr2 := generateParenthesis(n-i-1)</span><br><span class="line">		for k, sub := range substr1 &#123;</span><br><span class="line">			substr1[k] = &quot;(&quot; + sub + &quot;)&quot;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		for _, sub := range stingsMutiStrings(substr1, substr2) &#123;</span><br><span class="line">			if len(sub) != 0 &#123;</span><br><span class="line">				results = append(results, sub)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return results</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func stingsMutiStrings(str1 ,str2 []string) []string&#123;</span><br><span class="line">	if len(str1) == 0 &amp;&amp; len(str2) == 0 &#123;</span><br><span class="line">		return nil</span><br><span class="line">	&#125;</span><br><span class="line">	if len(str1) == 0 &#123;</span><br><span class="line">		return str2</span><br><span class="line">	&#125;</span><br><span class="line">	if len(str2) == 0 &#123;</span><br><span class="line">		return str1</span><br><span class="line">	&#125;</span><br><span class="line">	result := []string&#123;&#125;</span><br><span class="line">	for _, substr1 := range str1 &#123;</span><br><span class="line">		for _, substr2 := range str2 &#123;</span><br><span class="line">			sub := substr1 + substr2</span><br><span class="line">			result = append(result, sub)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>本周内容：How to write a microservice in Go with Go kit</p>
<p><a href="https://dev.to/napolux/how-to-write-a-microservice-in-go-with-go-kit-a66" target="_blank" rel="noopener">https://dev.to/napolux/how-to-write-a-microservice-in-go-with-go-kit-a66</a></p>
<p>首先，作者指出了学习使用Go kit的当前情况，样例很好，但Go kit的文档太生硬，市面上教程太少，所以写了这个例子，通过做来学习。</p>
<h3 id="做什么"><a href="#做什么" class="headerlink" title="做什么"></a>做什么</h3><p>我们的微服务由一些后端接口：</p>
<ul>
<li><code>GET /status</code> 返回微服务是否处在运行状态</li>
<li><code>GET /get</code>返回今天的日期</li>
<li><code>POST /validate</code>接收一个<code>dd/mm/yyyy</code>格式的日期字符串，通过正则判断其是否合法</li>
</ul>
<p>源码在：<br><a href="https://github.com/napolux/go-kit-microservice-example-tutorial-99999" target="_blank" rel="noopener">https://github.com/napolux/go-kit-microservice-example-tutorial-99999</a></p>
<h3 id="napodate微服务"><a href="#napodate微服务" class="headerlink" title="napodate微服务"></a>napodate微服务</h3><p>在$GOPATH目录下新建一个napodate目录，作为我们微服务的目录。在其中新建一个service.go的文件，然后在其中增加接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package napodate</span><br><span class="line"></span><br><span class="line">import &quot;context&quot;</span><br><span class="line"></span><br><span class="line">// Service provides some &quot;date capabilities&quot; to your application</span><br><span class="line">type Service interface &#123;</span><br><span class="line">    Status(ctx context.Context) (string, error)</span><br><span class="line">    Get(ctx context.Context) (string, error)</span><br><span class="line">    Validate(ctx context.Context, date string) (bool, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们定义了我们服务的“蓝图”： 在Go kit中，我们需要把服务抽象为接口。如上，我们需要三个端点来实现这个接口。</p>
<p>为什么要使用<code>context</code>包呢，请阅读<code>https://blog.golang.org/context</code>:</p>
<blockquote>
<p>在Google，我们开发了context包，使一个请求中的请求值，取消，超时传递到所有协程变的更容易</p>
</blockquote>
<p>因为我们的微服务从开始的时候就处理并行请求，所以每个请求一个context是必须的。</p>
<h3 id="实现我们的服务"><a href="#实现我们的服务" class="headerlink" title="实现我们的服务"></a>实现我们的服务</h3><p>前面我们定义了接口，但其是没有实现的，所以让我们来实现它：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">type dateService struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">// NewService makes a new Service.</span><br><span class="line">func NewService() Service &#123;</span><br><span class="line">    return dateService&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Status only tell us that our service is ok!</span><br><span class="line">func (dateService) Status(ctx context.Context) (string, error) &#123;</span><br><span class="line">    return &quot;ok&quot;, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Get will return today&apos;s date</span><br><span class="line">func (dateService) Get(ctx context.Context) (string, error) &#123;</span><br><span class="line">    now := time.Now()</span><br><span class="line">    return now.Format(&quot;02/01/2006&quot;), nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Validate will check if the date today&apos;s date</span><br><span class="line">func (dateService) Validate(ctx context.Context, date string) (bool, error) &#123;</span><br><span class="line">    _, err := time.Parse(&quot;02/01/2006&quot;, date)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return false, err</span><br><span class="line">    &#125;</span><br><span class="line">    return true, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过新定义的<code>dataService</code>（空结构），我们将服务的方法聚集在一起，并隐藏具体的方法实现。</p>
<p><code>NewService()</code>是我们对象的构造函数。我们通过调用它来获取服务实例。</p>
<h3 id="编写单元测试"><a href="#编写单元测试" class="headerlink" title="编写单元测试"></a>编写单元测试</h3><p>使用<code>NewService()</code>来编写我们的测试用例。创建<code>service_test.go</code>文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">package napodate</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;context&quot;</span><br><span class="line">    &quot;testing&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func TestStatus(t *testing.T) &#123;</span><br><span class="line">    srv, ctx := setup()</span><br><span class="line"></span><br><span class="line">    s, err := srv.Status(ctx)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        t.Errorf(&quot;Error: %s&quot;, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // testing status</span><br><span class="line">    ok := s == &quot;ok&quot;</span><br><span class="line">    if !ok &#123;</span><br><span class="line">        t.Errorf(&quot;expected service to be ok&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestGet(t *testing.T) &#123;</span><br><span class="line">    srv, ctx := setup()</span><br><span class="line">    d, err := srv.Get(ctx)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        t.Errorf(&quot;Error: %s&quot;, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time := time.Now()</span><br><span class="line">    today := time.Format(&quot;02/01/2006&quot;)</span><br><span class="line"></span><br><span class="line">    // testing today&apos;s date</span><br><span class="line">    ok := today == d</span><br><span class="line">    if !ok &#123;</span><br><span class="line">        t.Errorf(&quot;expected dates to be equal&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestValidate(t *testing.T) &#123;</span><br><span class="line">    srv, ctx := setup()</span><br><span class="line">    b, err := srv.Validate(ctx, &quot;31/12/2019&quot;)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        t.Errorf(&quot;Error: %s&quot;, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // testing that the date is valid</span><br><span class="line">    if !b &#123;</span><br><span class="line">        t.Errorf(&quot;date should be valid&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // testing an invalid date</span><br><span class="line">    b, err = srv.Validate(ctx, &quot;31/31/2019&quot;)</span><br><span class="line">    if b &#123;</span><br><span class="line">        t.Errorf(&quot;date should be invalid&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // testing a USA date date</span><br><span class="line">    b, err = srv.Validate(ctx, &quot;12/31/2019&quot;)</span><br><span class="line">    if b &#123;</span><br><span class="line">        t.Errorf(&quot;USA date should be invalid&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func setup() (srv Service, ctx context.Context) &#123;</span><br><span class="line">    return NewService(), context.Background()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上的测试代码是为了读者容易看到，但请你遵守<a href="https://blog.golang.org/subtests" target="_blank" rel="noopener"><code>Subtests, for a more up-to-date syntax</code></a>。</p>
<h3 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h3><p>我们的服务通过HTTP暴露。现在我们来设计HTTP请求和响应。在service.go的同级目录新建一个transport.go文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package napodate</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;context&quot;</span><br><span class="line">    &quot;encoding/json&quot;</span><br><span class="line">    &quot;net/http&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// In the first part of the file we are mapping requests and responses to their JSON payload.</span><br><span class="line">type getRequest struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">type getResponse struct &#123;</span><br><span class="line">    Date string `json:&quot;date&quot;`</span><br><span class="line">    Err  string `json:&quot;err,omitempty&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type validateRequest struct &#123;</span><br><span class="line">    Date string `json:&quot;date&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type validateResponse struct &#123;</span><br><span class="line">    Valid bool   `json:&quot;valid&quot;`</span><br><span class="line">    Err   string `json:&quot;err,omitempty&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type statusRequest struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">type statusResponse struct &#123;</span><br><span class="line">    Status string `json:&quot;status&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// In the second part we will write &quot;decoders&quot; for our incoming requests</span><br><span class="line">func decodeGetRequest(ctx context.Context, r *http.Request) (interface&#123;&#125;, error) &#123;</span><br><span class="line">    var req getRequest</span><br><span class="line">    return req, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func decodeValidateRequest(ctx context.Context, r *http.Request) (interface&#123;&#125;, error) &#123;</span><br><span class="line">    var req validateRequest</span><br><span class="line">    err := json.NewDecoder(r.Body).Decode(&amp;req)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return nil, err</span><br><span class="line">    &#125;</span><br><span class="line">    return req, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func decodeStatusRequest(ctx context.Context, r *http.Request) (interface&#123;&#125;, error) &#123;</span><br><span class="line">    var req statusRequest</span><br><span class="line">    return req, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Last but not least, we have the encoder for the response output</span><br><span class="line">func encodeResponse(ctx context.Context, w http.ResponseWriter, response interface&#123;&#125;) error &#123;</span><br><span class="line">    return json.NewEncoder(w).Encode(response)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以在作者博客中找到微服务源码，<a href="https://coding.napolux.com/how-to-write-a-microservice-in-go-with-go-kit/" target="_blank" rel="noopener">地址</a>。代码很少，但是其中包含了不少注释。</p>
<p>在这个文件的第一部分，我们将请求和响应映射为JSON文本。对于<code>statusRequest</code>与<code>getRequest</code>，由于其不会往服务端发送内容，所以为空。对于<code>validateRequest</code>，我们将传递一个日期来判断是否合法，所以其包含日期字段。响应也是同样的。</p>
<p>在第二部分，我们编写“解码器”来处理请求，告诉服务该怎么处理请求，怎么转换成正确的结构。<code>get</code>和<code>status</code>是空的，因为它们已完成。</p>
<p>最后，我们解码响应输出，即给定一个对象，返回json文本。</p>
<h3 id="端点"><a href="#端点" class="headerlink" title="端点"></a>端点</h3><p>新建一个<code>endpoint.go</code>文件。这个文件将包含我们的端口，其将请求映射到我们的内部服务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">package napodate</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;context&quot;</span><br><span class="line">    &quot;errors&quot;</span><br><span class="line"></span><br><span class="line">    &quot;github.com/go-kit/kit/endpoint&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// Endpoints are exposed</span><br><span class="line">type Endpoints struct &#123;</span><br><span class="line">    GetEndpoint      endpoint.Endpoint</span><br><span class="line">    StatusEndpoint   endpoint.Endpoint</span><br><span class="line">    ValidateEndpoint endpoint.Endpoint</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// MakeGetEndpoint returns the response from our service &quot;get&quot;</span><br><span class="line">func MakeGetEndpoint(srv Service) endpoint.Endpoint &#123;</span><br><span class="line">    return func(ctx context.Context, request interface&#123;&#125;) (interface&#123;&#125;, error) &#123;</span><br><span class="line">        _ = request.(getRequest) // we really just need the request, we don&apos;t use any value from it</span><br><span class="line">        d, err := srv.Get(ctx)</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">            return getResponse&#123;d, err.Error()&#125;, nil</span><br><span class="line">        &#125;</span><br><span class="line">        return getResponse&#123;d, &quot;&quot;&#125;, nil</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// MakeStatusEndpoint returns the response from our service &quot;status&quot;</span><br><span class="line">func MakeStatusEndpoint(srv Service) endpoint.Endpoint &#123;</span><br><span class="line">    return func(ctx context.Context, request interface&#123;&#125;) (interface&#123;&#125;, error) &#123;</span><br><span class="line">        _ = request.(statusRequest) // we really just need the request, we don&apos;t use any value from it</span><br><span class="line">        s, err := srv.Status(ctx)</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">            return statusResponse&#123;s&#125;, err</span><br><span class="line">        &#125;</span><br><span class="line">        return statusResponse&#123;s&#125;, nil</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// MakeValidateEndpoint returns the response from our service &quot;validate&quot;</span><br><span class="line">func MakeValidateEndpoint(srv Service) endpoint.Endpoint &#123;</span><br><span class="line">    return func(ctx context.Context, request interface&#123;&#125;) (interface&#123;&#125;, error) &#123;</span><br><span class="line">        req := request.(validateRequest)</span><br><span class="line">        b, err := srv.Validate(ctx, req.Date)</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">            return validateResponse&#123;b, err.Error()&#125;, nil</span><br><span class="line">        &#125;</span><br><span class="line">        return validateResponse&#123;b, &quot;&quot;&#125;, nil</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Get endpoint mapping</span><br><span class="line">func (e Endpoints) Get(ctx context.Context) (string, error) &#123;</span><br><span class="line">    req := getRequest&#123;&#125;</span><br><span class="line">    resp, err := e.GetEndpoint(ctx, req)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return &quot;&quot;, err</span><br><span class="line">    &#125;</span><br><span class="line">    getResp := resp.(getResponse)</span><br><span class="line">    if getResp.Err != &quot;&quot; &#123;</span><br><span class="line">        return &quot;&quot;, errors.New(getResp.Err)</span><br><span class="line">    &#125;</span><br><span class="line">    return getResp.Date, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Status endpoint mapping</span><br><span class="line">func (e Endpoints) Status(ctx context.Context) (string, error) &#123;</span><br><span class="line">    req := statusRequest&#123;&#125;</span><br><span class="line">    resp, err := e.StatusEndpoint(ctx, req)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return &quot;&quot;, err</span><br><span class="line">    &#125;</span><br><span class="line">    statusResp := resp.(statusResponse)</span><br><span class="line">    return statusResp.Status, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Validate endpoint mapping</span><br><span class="line">func (e Endpoints) Validate(ctx context.Context, date string) (bool, error) &#123;</span><br><span class="line">    req := validateRequest&#123;Date: date&#125;</span><br><span class="line">    resp, err := e.ValidateEndpoint(ctx, req)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return false, err</span><br><span class="line">    &#125;</span><br><span class="line">    validateResp := resp.(validateResponse)</span><br><span class="line">    if validateResp.Err != &quot;&quot; &#123;</span><br><span class="line">        return false, errors.New(validateResp.Err)</span><br><span class="line">    &#125;</span><br><span class="line">    return validateResp.Valid, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了把我们的服务方法<code>Get()</code>、<code>Status()</code>、<code>Validate()</code>暴露为端点，我们需要编写函数来处理输入请求，调用响应的服务方法，根据响应报文将构建返回合适的对象。</p>
<p>这些方法是上面的那些<code>make</code>函数。它们将接收服务作为参数，然后使用断言强制转换请求类型，再使用转换后的类型来调用服务的方法。</p>
<h3 id="HTTP服务"><a href="#HTTP服务" class="headerlink" title="HTTP服务"></a>HTTP服务</h3><p>对于微服务，我们需要HTTP服务。Go相当擅长于此，但是我还是选择<a href="https://github.com/gorilla/mux作为路由，因为它看起来简单直接。" target="_blank" rel="noopener">https://github.com/gorilla/mux作为路由，因为它看起来简单直接。</a></p>
<p>再新建一个<code>server.go</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package napodate</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;context&quot;</span><br><span class="line">    &quot;net/http&quot;</span><br><span class="line"></span><br><span class="line">    httptransport &quot;github.com/go-kit/kit/transport/http&quot;</span><br><span class="line">    &quot;github.com/gorilla/mux&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// NewHTTPServer is a good little server</span><br><span class="line">func NewHTTPServer(ctx context.Context, endpoints Endpoints) http.Handler &#123;</span><br><span class="line">    r := mux.NewRouter()</span><br><span class="line">    r.Use(commonMiddleware) // @see https://stackoverflow.com/a/51456342</span><br><span class="line"></span><br><span class="line">    r.Methods(&quot;GET&quot;).Path(&quot;/status&quot;).Handler(httptransport.NewServer(</span><br><span class="line">        endpoints.StatusEndpoint,</span><br><span class="line">        decodeStatusRequest,</span><br><span class="line">        encodeResponse,</span><br><span class="line">    ))</span><br><span class="line"></span><br><span class="line">    r.Methods(&quot;GET&quot;).Path(&quot;/get&quot;).Handler(httptransport.NewServer(</span><br><span class="line">        endpoints.GetEndpoint,</span><br><span class="line">        decodeGetRequest,</span><br><span class="line">        encodeResponse,</span><br><span class="line">    ))</span><br><span class="line"></span><br><span class="line">    r.Methods(&quot;POST&quot;).Path(&quot;/validate&quot;).Handler(httptransport.NewServer(</span><br><span class="line">        endpoints.ValidateEndpoint,</span><br><span class="line">        decodeValidateRequest,</span><br><span class="line">        encodeResponse,</span><br><span class="line">    ))</span><br><span class="line"></span><br><span class="line">    return r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func commonMiddleware(next http.Handler) http.Handler &#123;</span><br><span class="line">    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">        w.Header().Add(&quot;Content-Type&quot;, &quot;application/json&quot;)</span><br><span class="line">        next.ServeHTTP(w, r)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="最后，main-go文件"><a href="#最后，main-go文件" class="headerlink" title="最后，main.go文件"></a>最后，main.go文件</h3><p>我们有端点，有HTTP服务，现在我们只需要把这些包起来。这就是main.go文件。我们新建一个文件夹cmd：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;context&quot;</span><br><span class="line">    &quot;flag&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;log&quot;</span><br><span class="line">    &quot;net/http&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">    &quot;os/signal&quot;</span><br><span class="line">    &quot;syscall&quot;</span><br><span class="line"></span><br><span class="line">    &quot;napodate&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var (</span><br><span class="line">        httpAddr = flag.String(&quot;http&quot;, &quot;:8080&quot;, &quot;http listen address&quot;)</span><br><span class="line">    )</span><br><span class="line">    flag.Parse()</span><br><span class="line">    ctx := context.Background()</span><br><span class="line">    // our napodate service</span><br><span class="line">    srv := napodate.NewService()</span><br><span class="line">    errChan := make(chan error)</span><br><span class="line"></span><br><span class="line">    go func() &#123;</span><br><span class="line">        c := make(chan os.Signal, 1)</span><br><span class="line">        signal.Notify(c, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line">        errChan &lt;- fmt.Errorf(&quot;%s&quot;, &lt;-c)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    // mapping endpoints</span><br><span class="line">    endpoints := napodate.Endpoints&#123;</span><br><span class="line">        GetEndpoint:      napodate.MakeGetEndpoint(srv),</span><br><span class="line">        StatusEndpoint:   napodate.MakeStatusEndpoint(srv),</span><br><span class="line">        ValidateEndpoint: napodate.MakeValidateEndpoint(srv),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // HTTP transport</span><br><span class="line">    go func() &#123;</span><br><span class="line">        log.Println(&quot;napodate is listening on port:&quot;, *httpAddr)</span><br><span class="line">        handler := napodate.NewHTTPServer(ctx, endpoints)</span><br><span class="line">        errChan &lt;- http.ListenAndServe(*httpAddr, handler)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    log.Fatalln(&lt;-errChan)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用flag来让监听端口可配置，服务默认的端口是8080，我们可以通过flag指定任意端口。</p>
<p>接下来，我们创建了一个上下文，获取到我们的服务，error管道也同时创建出来。</p>
<p>然后我们创建了两个协程，一个用来接收<code>CTRL+C</code>来停止服务，另一个接收请求。</p>
<p><code>handler := napodate.NewHTTPServer(ctx, endpoints)</code>这个handler将映射我们的endpoints服务并返回正确的结果。</p>
<p>最后error管道接收到错误信息，服务停止</p>
<h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>运行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run cmd/main.go</span><br></pre></td></tr></table></figure></p>
<p>通过curl微服务来测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:8080/get</span><br><span class="line">&#123;&quot;date&quot;:&quot;14/04/2019&quot;&#125;</span><br><span class="line"></span><br><span class="line">curl http://localhost:8080/status</span><br><span class="line">&#123;&quot;status&quot;:&quot;ok&quot;&#125;</span><br><span class="line"></span><br><span class="line">curl -XPOST -d &apos;&#123;&quot;date&quot;:&quot;32/12/2020&quot;&#125;&apos; http://localhost:8080/validate</span><br><span class="line">&#123;&quot;valid&quot;:false,&quot;err&quot;:&quot;parsing time \&quot;32/12/2020\&quot;: day out of range&quot;&#125;</span><br><span class="line"></span><br><span class="line">curl -XPOST -d &apos;&#123;&quot;date&quot;:&quot;12/12/2021&quot;&#125;&apos; http://localhost:8080/validate</span><br><span class="line">&#123;&quot;valid&quot;:true&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>分享 cookie、 sessionStorage 、localStorage之间的区别和使用</p>
<p>1.cookie:存储在用户本地终端上的数据。有时也用cookies，指某些网站为了辨别用户身份，进行session跟踪而存储在本地终端上的数据，通常经过加密。一般应用最典型的案列就是判断注册用户是否已经登过该网站。</p>
<p>2.HTML5 提供了两种在客户端存储数据的新方法：(<a href="http://www.w3school.com.cn/html5/html_5_webstorage.asp)...两者都是仅在客户端（即浏览器）中保存，不参与和服务器的通信；" target="_blank" rel="noopener">http://www.w3school.com.cn/html5/html_5_webstorage.asp)...两者都是仅在客户端（即浏览器）中保存，不参与和服务器的通信；</a></p>
<ul>
<li>localStorage - 没有时间限制的数据存储,第二天、第二周或下一年之后，数据依然可用。</li>
<li></li>
<li>如何创建和访问 localStorage：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">localStorage.lastname=&quot;Smith&quot;;</span><br><span class="line">document.write(localStorage.lastname);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>下面的例子对用户访问页面的次数进行计数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">if (localStorage.pagecount)&#123;</span><br><span class="line">  localStorage.pagecount=Number(localStorage.pagecount) +1;</span><br><span class="line">  &#125;</span><br><span class="line">else&#123;</span><br><span class="line">  localStorage.pagecount=1;</span><br><span class="line">  &#125;</span><br><span class="line">document.write(&quot;Visits &quot;+ localStorage.pagecount + &quot; time(s).&quot;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>sessionStorage - 针对一个 session 的数据存储,当用户关闭浏览器窗口后，数据会被删除。</p>
</li>
<li><p>创建并访问一个 sessionStorage：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">  sessionStorage.lastname=&quot;Smith&quot;;</span><br><span class="line">  document.write(sessionStorage.lastname);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>下面的例子对用户在当前 session 中访问页面的次数进行计数：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">if (sessionStorage.pagecount)&#123;</span><br><span class="line">  sessionStorage.pagecount=Number(sessionStorage.pagecount) +1;</span><br><span class="line">  &#125;</span><br><span class="line">else&#123;</span><br><span class="line">  sessionStorage.pagecount=1;</span><br><span class="line">  &#125;</span><br><span class="line">document.write(&quot;Visits &quot;+sessionStorage.pagecount+&quot; time(s) this session.&quot;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>sessionStorage 、localStorage 和 cookie 之间的区别<br>共同点：都是保存在浏览器端，且同源的。</p>
</li>
<li><p>区别：cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递；cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。</p>
</li>
<li><p>而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</p>
</li>
<li><p>数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。</p>
</li>
<li><p>作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。Web Storage 的 api 接口使用更方便。</p>
</li>
</ul>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>golang的container/heap包详解： <a href="https://ieevee.com/tech/2018/01/29/go-heap.html" target="_blank" rel="noopener">https://ieevee.com/tech/2018/01/29/go-heap.html</a></p>
<p>在leetcode的刷题过程中，遇到优先队列的问题，go的优先队列在container/heap包中，可以看下以上的链接。</p>


                
            </div>

            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    


                </div>
            
        </div>
    </div>
</article>

    <!-- Footer -->
    <hr />

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    

                    

                    
                        <li>
                            <a href="https://github.com/Leitty" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    

                    
                        <li>
                            <a href="mailto:gleiying@gmail.com" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-envelope-o fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    
                </ul>
                <p class="copyright text-muted">&copy; 2019 Leitty<br></p>
                <p class="copyright text-muted">Original Theme <a target="_blank" href="http://startbootstrap.com/template-overviews/clean-blog/">Clean Blog</a> from <a href="http://startbootstrap.com/" target="_blank">Start Bootstrap</a></p>
                <p class="copyright text-muted">Adapted for <a target="_blank" href="https://hexo.io/">Hexo</a> by <a href="http://www.codeblocq.com/" target="_blank">Jonathan Klughertz</a></p>
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Bootstrap -->
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->



</body>

</html>